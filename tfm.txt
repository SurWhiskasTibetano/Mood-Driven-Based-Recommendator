# Create the 7-file refactor as actual files the user can download.
import os, textwrap, json

base = "/mnt/data/emo_reco"
os.makedirs(base, exist_ok=True)

files = {}

files["config.py"] = r'''
import os
import googlemaps
import streamlit as st
from dotenv import load_dotenv

# --------- Claves desde .env ---------
load_dotenv()
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
GOOGLE_MAPS_API_KEY = os.getenv("GOOGLE_MAPS_API_KEY")

if not GOOGLE_MAPS_API_KEY:
    st.error("Falta GOOGLE_MAPS_API_KEY en .env")
    st.stop()

# Cliente Google Maps
gmaps = googlemaps.Client(key=GOOGLE_MAPS_API_KEY)

# --------- Constantes de UI ---------
LIST_CONTAINER_HEIGHT_PX = 720  # altura del contenedor scrollable

# --------- Pesos del score ---------
W_RATING = 0.5
W_REVIEWS = 0.3
W_PROX = 0.2
'''.strip()

files["taxonomy.py"] = r'''
import re
import random
import unicodedata

def _norm(t: str) -> str:
    t = (t or "").lower()
    t = unicodedata.normalize("NFD", t)
    return "".join(c for c in t if unicodedata.category(c) != "Mn")

# Curado amplio por emoci√≥n (gu√≠a + fallback)
CURATED_BY_CATEGORY = {
    "tristeza": [
        "parque luminoso", "jard√≠n bot√°nico", "mirador tranquilo", "paseo junto al agua",
        "cafeter√≠a acogedora", "librer√≠a", "museo", "centro cultural", "teter√≠a",
        "paseo urbano", "exposici√≥n de arte", "cine", "terraza tranquila",
        "paseo fluvial", "sendero f√°cil", "espacio verde amplio", "museo de historia",
        "museo de arte", "galer√≠a", "m√∫sica suave"
    ],
    "ansiedad/estr√©s": [
        "parque", "jard√≠n bot√°nico", "spa", "teter√≠a", "yoga", "paseo fluvial", "mirador",
        "cafeter√≠a tranquila", "ba√±os √°rabes", "paseo por la playa", "bosque urbano", "biblioteca",
        "meditaci√≥n", "camino perimetral", "sendero f√°cil", "pistas de caminar", "masaje",
        "paseo por el r√≠o", "templo", "jard√≠n zen"
    ],
    "ira": [
        "gimnasio", "boxeo", "roc√≥dromo", "piscina", "running", "crossfit",
        "pista de p√°del", "circuito de bici", "pista de atletismo",
        "parque de trampolines", "kickboxing", "calistenia", "boulder",
        "sauna tras ejercicio", "ba√±o fr√≠o", "spinning", "clase de baile en√©rgica"
    ],
    "cansancio": [
        "cafeter√≠a", "teter√≠a", "librer√≠a", "cine", "helader√≠a", "terraza con sombra", "spa",
        "museo peque√±o", "paseo corto", "sala de lectura", "galer√≠a", "chill-out",
        "parque de barrio", "brunch tranquilo", "mirador con bancos", "sala de t√©",
        "cafeter√≠a con sof√°s", "biblioteca"
    ],
    "soledad": [
        "cafeter√≠a mesas compartidas", "coworking", "taller", "voluntariado", "biblioteca",
        "centro cultural", "clase grupal", "club de lectura", "juegos de mesa", "intercambio de idiomas",
        "bar de vermut tranquilo", "mesas largas", "colectivo creativo", "huerto urbano",
        "mercadillo", "asociaci√≥n", "meetup", "coro"
    ],
    "aburrimiento": [
        "escape room", "arcade", "bolera", "taller creativo", "museo interactivo", "mercadillo",
        "minigolf", "sal√≥n de juegos", "karaoke", "paintball", "laser tag",
        "feria", "parque tem√°tico peque√±o", "cer√°mica", "clase de cocina",
        "b√∫squeda del tesoro", "gincana", "patinaje", "realidad virtual"
    ],
    "felicidad": [
        "discoteca", "bar de c√≥cteles", "karaoke", "rooftop", "conciertos", "tapas",
        "terraza con vistas", "club de comedia", "sala de conciertos", "mercado gastron√≥mico",
        "bar musical", "baile social", "fiesta latina", "festival", "speakeasy",
        "brunch animado", "taberna moderna", "food market"
    ],
    "amor/romance": [
        "mirador", "parque", "terraza rom√°ntica", "restaurante √≠ntimo", "paseo atardecer",
        "jard√≠n bot√°nico", "bar de vinos", "bistr√≥", "azotea tranquila", "casco antiguo",
        "paseo fluvial", "velas", "caf√© con encanto", "degustaci√≥n de vinos",
        "jardines", "museo peque√±o", "rinc√≥n fotogr√°fico", "patio"
    ],
    "curiosidad": [
        "museo", "galer√≠a", "centro cultural", "taller", "librer√≠a", "museo de ciencias",
        "exposici√≥n temporal", "archivo hist√≥rico", "ruta guiada", "museo interactivo", "visita a estudio",
        "itinerario urbano", "centro de innovaci√≥n", "artesan√≠a", "ruta de murales",
        "visita teatralizada", "planetario", "observatorio", "aula de naturaleza"
    ],
    "calma/paz": [
        "spa", "jard√≠n bot√°nico", "paseo junto al agua", "teter√≠a", "templo",
        "biblioteca", "parque amplio", "ba√±os √°rabes", "paseo por lago", "sendero f√°cil",
        "mirador al amanecer", "paseo mar√≠timo", "parque con estanque", "ribera del r√≠o",
        "meditaci√≥n", "yoga suave", "reserva natural", "ermita"
    ],
    "neutro": [
        "parque", "cafeter√≠a", "museo", "mirador", "librer√≠a", "paseo urbano", "galer√≠a",
        "mercadillo", "centro cultural", "paseo junto al agua"
    ],
}

# Palabras clave viables para Google Nearby (canon)
CANON_KEYWORDS = [
    # Naturaleza / paseo
    "parque", "jard√≠n bot√°nico", "mirador", "paseo fluvial", "paseo mar√≠timo", "reserva natural",
    "playa", "sendero", "ribera del r√≠o",
    # Caf√©s y relax
    "cafeter√≠a", "teter√≠a", "helader√≠a", "chill-out",
    # Cultura
    "museo", "galer√≠a de arte", "centro cultural", "biblioteca", "archivo hist√≥rico",
    "museo de ciencias", "planetario", "observatorio",
    # Bienestar
    "spa", "ba√±os √°rabes", "masaje", "yoga", "meditaci√≥n", "sauna",
    # Deporte / descarga
    "gimnasio", "boxeo", "roc√≥dromo", "piscina", "pista de p√°del", "crossfit",
    "pista de atletismo", "parque de trampolines", "escalada",
    # Ocio
    "escape room", "bolera", "arcade", "karaoke", "minigolf", "laser tag", "paintball", "realidad virtual",
    # Social / comunidad
    "coworking", "club de lectura", "intercambio de idiomas", "asociaci√≥n",
    # Noche / celebraci√≥n
    "discoteca", "bar de c√≥cteles", "rooftop", "sala de conciertos", "club de comedia",
    "bar de vinos", "vinoteca", "bistr√≥", "mercado gastron√≥mico",
    # Restauraci√≥n rom√°ntica
    "restaurante rom√°ntico", "caf√© con encanto",
]

SYNONYMS_TO_CANON = {
    # Naturaleza / paseo
    r"\bparque luminoso\b": "parque",
    r"\bparque de barrio\b": "parque",
    r"\bpaseo junto al agua\b": "paseo fluvial",
    r"\bpaseo por el r√≠o\b": "paseo fluvial",
    r"\bpaseo por la playa\b": "paseo mar√≠timo",
    r"\bribera\b": "ribera del r√≠o",
    r"\bsendero f√°cil\b": "sendero",
    r"\bruta corta\b": "sendero",
    r"\bbosque urbano\b": "parque",
    r"\bespacio verde\b": "parque",
    r"\bmirador tranquilo\b": "mirador",
    r"\bmirador con bancos\b": "mirador",
    # Caf√©s / relax
    r"\bcafeter[i√≠]a acogedora\b": "cafeter√≠a",
    r"\bcafeter[i√≠]a tranquila\b": "cafeter√≠a",
    r"\bcafeter[i√≠]a con sof[a√°]s\b": "cafeter√≠a",
    r"\bsala de t[e√©]\b": "teter√≠a",
    r"\bchill[- ]?out\b": "chill-out",
    # Cultura
    r"\bexposici[o√≥]n de arte\b": "galer√≠a de arte",
    r"\bgaler[i√≠]a\b": "galer√≠a de arte",
    r"\bmuseo de arte\b": "museo",
    r"\bmuseo peque[n√±]o\b": "museo",
    r"\bmuseo interactivo\b": "museo",
    r"\bcentro de innovaci[o√≥]n\b": "centro cultural",
    r"\bruta guiada\b": "centro cultural",
    r"\bitinerario urbano\b": "centro cultural",
    # Bienestar
    r"\bba[n√±]os (arabes|a[r√°]bes)\b": "ba√±os √°rabes",
    r"\btemplo|silencio\b": "templo",
    # Deporte / descarga
    r"\brunning\b": "pista de atletismo",
    r"\bboulder\b": "roc√≥dromo",
    r"\bclase de baile en[√©e]rgica\b": "gimnasio",
    r"\bcalistenia\b": "gimnasio",
    # Ocio
    r"\bsal[o√≥]n de juegos\b": "arcade",
    r"\bparque tem[a√°]tico peque[n√±]o\b": "mini golf",
    r"\bgim?c?ana|gincana\b": "escape room",
    r"\bb[u√∫]squeda del tesoro\b": "escape room",
    r"\bferia\b": "mercado gastron√≥mico",
    r"\bclase de cocina\b": "centro cultural",
    r"\btaller creativo|cer[a√°]mica\b": "centro cultural",
    # Social / comunidad
    r"\bmesas compartidas\b": "cafeter√≠a",
    r"\bcolectivo creativo\b": "centro cultural",
    r"\bvoluntariado\b": "asociaci√≥n",
    r"\bmeetup\b": "centro cultural",
    r"\bhuerto urbano\b": "asociaci√≥n",
    # Noche / romance
    r"\brooftop\b": "rooftop",
    r"\bazotea\b": "rooftop",
    r"\bbar de vermut\b": "bar de c√≥cteles",
    r"\bbar con velas\b": "bar de vinos",
    r"\bdegustaci[o√≥]n de vinos\b": "vinoteca",
    r"\bcaf[e√©] con encanto\b": "caf√© con encanto",
}

# Canon por emoci√≥n para completar variedad
CANON_BY_EMOTION = {
    "tristeza": [
        "parque", "jard√≠n bot√°nico", "mirador", "paseo fluvial", "cafeter√≠a",
        "librer√≠a", "museo", "teter√≠a", "centro cultural", "biblioteca"
    ],
    "ansiedad/estr√©s": [
        "parque", "jard√≠n bot√°nico", "paseo fluvial", "paseo mar√≠timo", "spa",
        "teter√≠a", "meditaci√≥n", "yoga", "ba√±os √°rabes", "biblioteca"
    ],
    "ira": [
        "gimnasio", "boxeo", "roc√≥dromo", "piscina", "pista de p√°del",
        "crossfit", "pista de atletismo", "parque de trampolines", "sauna"
    ],
    "cansancio": [
        "cafeter√≠a", "teter√≠a", "librer√≠a", "cine", "spa", "museo",
        "galer√≠a de arte", "parque", "chill-out", "biblioteca"
    ],
    "soledad": [
        "cafeter√≠a", "coworking", "club de lectura", "intercambio de idiomas",
        "centro cultural", "biblioteca", "asociaci√≥n", "cafeter√≠a"
    ],
    "aburrimiento": [
        "escape room", "arcade", "bolera", "karaoke", "minigolf",
        "laser tag", "paintball", "realidad virtual"
    ],
    "felicidad": [
        "discoteca", "bar de c√≥cteles", "rooftop", "sala de conciertos",
        "club de comedia", "mercado gastron√≥mico", "bar de vinos"
    ],
    "amor/romance": [
        "mirador", "parque", "bar de vinos", "vinoteca", "bistr√≥",
        "restaurante rom√°ntico", "caf√© con encanto", "rooftop", "paseo fluvial"
    ],
    "curiosidad": [
        "museo", "galer√≠a de arte", "centro cultural", "museo de ciencias",
        "planetario", "observatorio", "biblioteca"
    ],
    "calma/paz": [
        "spa", "jard√≠n bot√°nico", "paseo fluvial", "paseo mar√≠timo",
        "templo", "meditaci√≥n", "yoga", "biblioteca", "parque"
    ],
    "neutro": [
        "parque", "cafeter√≠a", "museo", "mirador", "galer√≠a de arte",
        "centro cultural", "paseo fluvial"
    ],
}

def _map_term_to_canon(term: str, category_hint: str = "neutro") -> str:
    """Mapea un t√©rmino a una keyword can√≥nica Nearby-friendly."""
    t = _norm(term)
    # 1) Sin√≥nimos por regex
    for pat, canon in SYNONYMS_TO_CANON.items():
        if re.search(pat, t):
            return canon
    # 2) Coincidencia directa con canon
    for canon in CANON_KEYWORDS:
        if _norm(canon) in t or t in _norm(canon):
            return canon
    # 3) Heur√≠stica
    t_simple = re.sub(r"\b(tranquil[ao]s?|acogedor[ao]s?|rom[a√°]ntic[ao]s?|peque[√±n]o[s]?)\b", "", t).strip()
    for canon in CANON_KEYWORDS:
        if _norm(canon) == t_simple:
            return canon
    # 4) Fallback por emoci√≥n
    pool = CANON_BY_EMOTION.get(category_hint, CANON_BY_EMOTION["neutro"])
    return random.choice(pool)
'''.strip()

files["brain.py"] = r'''
import re
import json
import random
import requests
from config import GEMINI_API_KEY
from taxonomy import (
    CURATED_BY_CATEGORY,
    CANON_BY_EMOTION,
    _map_term_to_canon,
    _norm,
)

def detect_mood_category(mood_text: str) -> str:
    """Heur√≠stica robusta (fallback) con regex y l√≠mites de palabra."""
    p = _norm(mood_text)
    rules = [
        ("tristeza", [
            r"\bmuy mal\b", r"\bmal\b", r"\bfatal\b", r"\bhorrible\b", r"\bbajon\b", r"\bme siento mal\b",
            r"\bdepre", r"\bdeprim", r"\bmelanc", r"\bdesanim", r"\bllor", r"\bvac[i√≠]o\b"
        ]),
        ("ansiedad/estr√©s", [r"\bansied", r"\bnervios\b", r"\bagobio\b", r"\bestres\b", r"\bangust", r"\bpreocup"]),
        ("ira", [r"\bira\b", r"\benfad", r"\brabia\b", r"\bfuria\b", r"\bcabre", r"\benoj"]),
        ("cansancio", [r"\bcansancio\b", r"\bcansad", r"\bagotad", r"\bfatiga\b", r"\bburnout\b", r"\bsin fuerzas\b"]),
        ("soledad", [r"\bsoledad\b", r"\bsolo\b", r"\bsola\b", r"\baislad", r"\baislam"]),
        ("aburrimiento", [r"\baburr", r"\bapat", r"\bsin ganas\b", r"\bapatico\b", r"\bapatica\b"]),
        ("felicidad", [r"\bfeliz\b", r"\bcontent", r"\balegr", r"\beufor", r"\bgenial\b", r"\bde lujo\b"]),
        ("amor/romance", [r"\bamor\b", r"\benamora", r"\bromant", r"\bcari√±", r"\brom[a√°]nt"]),
        ("curiosidad", [r"\bcurios", r"\bcreativ", r"\binspir", r"\bexplor", r"\bdescubr"]),
        ("calma/paz", [r"\bcalma\b", r"\bpaz\b", r"\btranquil", r"\bseren", r"\brelajad"]),
    ]
    for category, pats in rules:
        if any(re.search(pat, p) for pat in pats):
            return category
    return "neutro"

TONE_HINTS = {
    "tristeza":        ("c√°lido y suave",            "üòî"),
    "ansiedad/estr√©s": ("calmante y tranquilizador", "üò•"),
    "ira":             ("validante y sereno",         "üí¢"),
    "cansancio":       ("reconfortante",              "üòÆ‚Äçüí®"),
    "soledad":         ("acogedor",                   "ü§ç"),
    "aburrimiento":    ("ligero y motivador",         "üôÇ"),
    "felicidad":       ("alegre y entusiasta",        "üéâ"),
    "amor/romance":    ("tierno y c√≥mplice",          "üíû"),
    "curiosidad":      ("inspirador",                 "üå±"),
    "calma/paz":       ("sereno",                     "üßò"),
    "neutro":          ("c√°lido y cercano",           "üôÇ"),
}

def _fallback_empathy(mood_text: str) -> str:
    category = detect_mood_category(mood_text)
    _, emoji = TONE_HINTS.get(category, TONE_HINTS["neutro"])
    templates = {
        "tristeza":        f"Siento mucho que est√©s pasando por esto {emoji}. Voy a recomendarte algunos lugares suaves para ayudarte un poco.",
        "ansiedad/estr√©s": f"Suena intenso; vamos a bajar revoluciones {emoji}. Te recomendar√© sitios tranquilos para desconectar un poco.",
        "ira":             f"Tiene sentido que te sientas as√≠ {emoji}. Te propondr√© opciones para liberar tensi√≥n de forma sana.",
        "cansancio":       f"Se nota el cansancio {emoji}. Te sugerir√© lugares para recargar pilas con calma.",
        "soledad":         f"Aqu√≠ estoy contigo {emoji}. Te propondr√© sitios donde puedas sentirte acompa√±ado/a a tu ritmo.",
        "aburrimiento":    f"A veces apetece algo distinto {emoji}. Te recomendar√© planes con un poco de chispa.",
        "felicidad":       f"¬°Qu√© alegr√≠a leerte! {emoji} Te propondr√© lugares para celebrarlo a tu manera.",
        "amor/romance":    f"Qu√© bonito momento {emoji}. Te sugerir√© rincones con buena atm√≥sfera para un plan especial.",
        "curiosidad":      f"Esa curiosidad es oro {emoji}. Te propondr√© lugares que inviten a explorar.",
        "calma/paz":       f"Qu√© bien sentir esa paz {emoji}. Te sugerir√© sitios para seguir cuidando ese bienestar.",
        "neutro":          f"Estoy aqu√≠ contigo üôÇ. Te recomendar√© algunos lugares pensados para ti.",
    }
    return templates.get(category, templates["neutro"])

PROMPT_BRAIN_JSON = """ Eres un asistente en espa√±ol (Espa√±a). Analiza el estado del usuario y devuelve SOLO un JSON con esta forma: 
{
  "category": "tristeza|ansiedad/estr√©s|ira|cansancio|soledad|aburrimiento|felicidad|amor/romance|curiosidad|calma/paz",
  "empathy": "1-2 frases, tono acorde a la emoci√≥n, EXACTAMENTE 1 emoji, NO empieces con 'Gracias por compartir'",
  "place_types": ["3 a 6 tipos de lugares en Espa√±a, min√∫sculas, 1-3 palabras, sin nombres propios"]
}
Criterios:
- Var√≠a los tipos de lugares; evita repetir siempre los mismos.
- Ajusta interior/exterior y social/individual seg√∫n la emoci√≥n.
- Deben ser lugares factibles para buscar en Google Maps Nearby en Espa√±a.
- Ejemplos (no los devuelvas tal cual): parque, jard√≠n bot√°nico, mirador, paseo fluvial, cafeter√≠a, teter√≠a, helader√≠a, librer√≠a,
  museo, galer√≠a de arte, centro cultural, biblioteca, spa, ba√±os √°rabes, masaje, yoga, meditaci√≥n, gimnasio, boxeo, roc√≥dromo,
  piscina, pista de p√°del, crossfit, pista de atletismo, parque de trampolines, escape room, bolera, arcade, karaoke, minigolf,
  laser tag, paintball, realidad virtual, coworking, club de lectura, intercambio de idiomas, discoteca, bar de c√≥cteles,
  rooftop, sala de conciertos, club de comedia, bar de vinos, vinoteca, bistr√≥, mercado gastron√≥mico, restaurante rom√°ntico,
  caf√© con encanto, planetario, observatorio, reserva natural, templo.
- Si paso ‚ÄúEvita‚Äù, no uses esos tipos ni sin√≥nimos.

Estado del usuario: ¬´{mood}¬ª
Evita (si hay): {avoid}
""".strip()

def gemini_brain(mood_text: str, avoid_terms: list[str] | None = None):
    """Devuelve (empathy_message, place_types, category) usando Gemini (JSON estricto)."""
    if not GEMINI_API_KEY:
        raise RuntimeError("GEMINI_API_KEY missing")

    avoid = ", ".join(sorted(set((avoid_terms or [])[:12])))
    prompt = PROMPT_BRAIN_JSON.format(mood=mood_text, avoid=avoid if avoid else "‚Äî")

    url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent"
    headers = {"Content-Type": "application/json"}
    payload = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {
            "temperature": 0.9,
            "topP": 0.95,
            "maxOutputTokens": 350,
            "responseMimeType": "application/json"
        }
    }
    params = {"key": GEMINI_API_KEY}
    resp = requests.post(url, headers=headers, params=params, data=json.dumps(payload), timeout=20)
    resp.raise_for_status()
    data = resp.json()

    raw = data["candidates"][0]["content"]["parts"][0]["text"]
    obj = json.loads(raw)

    empathy = str(obj.get("empathy", "")).strip()
    places = [str(x).strip().lower() for x in obj.get("place_types", []) if str(x).strip()]
    category = str(obj.get("category", "")).strip().lower()

    if not empathy or not places:
        raise ValueError("JSON incompleto")

    # Filtra evitados y de-dup
    avoid_set = {a.lower() for a in (avoid_terms or [])}
    places = [p for p in places if p not in avoid_set]
    places = list(dict.fromkeys(places))[:6]
    return empathy, places, category

def normalize_to_nearby_keywords(recommended: list[str], category: str, avoid: list[str]) -> list[str]:
    """Normaliza los tipos devueltos por Gemini a keywords viables para Nearby."""
    avoid_set = {a.lower() for a in avoid}
    out = []
    for t in recommended:
        canon = _map_term_to_canon(t, category_hint=category or "neutro")
        if canon.lower() not in avoid_set and canon not in out:
            out.append(canon)
        if len(out) >= 6:
            break
    if len(out) < 3:
        pool = [x for x in CANON_BY_EMOTION.get(category or "neutro", CANON_BY_EMOTION["neutro"]) if x not in out and x not in avoid_set]
        random.shuffle(pool)
        out.extend(pool[: (6 - len(out))])
    return out

def mock_from_mood(mood_text: str, avoid: list[str] | None = None):
    """Fallback cl√°sico: muestrea del curado y normaliza a keywords Nearby."""
    category = detect_mood_category(mood_text)
    avoid = avoid or []
    candidates = CURATED_BY_CATEGORY.get(category, CURATED_BY_CATEGORY["neutro"])[:]
    random.shuffle(candidates)
    raw = []
    for c in candidates:
        if len(raw) >= 6:
            break
        raw.append(c)
    return normalize_to_nearby_keywords(raw, category, avoid)
'''.strip()

files["maps_io.py"] = r'''
import streamlit as st
from urllib.parse import quote_plus
from config import gmaps, GOOGLE_MAPS_API_KEY

def _maps_link(lat, lon):
    return f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"

def gm_embed_directions_url(
    origin_text: str,
    dest_place_id: str | None = None,
    dest_text: str | None = None,
    mode: str = "driving",
    waypoints_latlon: list[tuple[float, float]] | None = None,
):
    base = "https://www.google.com/maps/embed/v1/directions"
    if not origin_text:
        raise ValueError("origin_text es obligatorio")
    if not (dest_place_id or dest_text):
        raise ValueError("Debes pasar dest_place_id o dest_text")
    params = [
        f"key={GOOGLE_MAPS_API_KEY}",
        f"origin={quote_plus(origin_text)}",
        f"mode={mode}",
    ]
    if dest_place_id:
        params.append(f"destination=place_id:{dest_place_id}")
    else:
        params.append(f"destination={quote_plus(dest_text)}")
    if waypoints_latlon:
        wp_str = "|".join([f"{lat:.6f},{lon:.6f}" for (lat, lon) in waypoints_latlon])
        params.append(f"waypoints={quote_plus(wp_str)}")
    return f"{base}?{'&'.join(params)}"

def maps_directions_link(
    origin_text: str,
    dest_place_id: str | None = None,
    dest_text: str | None = None,
    mode: str = "driving",
    waypoints_latlon: list[tuple[float, float]] | None = None,
    optimize_waypoints: bool = False,
):
    base = "https://www.google.com/maps/dir/?api=1"
    if not origin_text:
        raise ValueError("origin_text es obligatorio")
    if not (dest_place_id or dest_text):
        raise ValueError("Debes pasar dest_place_id o dest_text")
    origin_param = f"origin={quote_plus(origin_text)}"
    dest_param = f"destination=place_id:{dest_place_id}" if dest_place_id else f"destination={quote_plus(dest_text)}"
    params = [origin_param, dest_param, f"travelmode={mode}"]
    if waypoints_latlon:
        wp_prefix = "optimize:true|" if optimize_waypoints else ""
        wp_body = "|".join([f"{lat:.6f},{lon:.6f}" for (lat, lon) in waypoints_latlon])
        params.append(f"waypoints={quote_plus(wp_prefix + wp_body)}")
    return f"{base}&{'&'.join(params)}"

def gm_embed_place_url(place_id=None, latlon=None):
    base = "https://www.google.com/maps/embed/v1/place"
    if place_id:
        return f"{base}?key={GOOGLE_MAPS_API_KEY}&q=place_id:{place_id}"
    if latlon:
        return f"{base}?key={GOOGLE_MAPS_API_KEY}&q={latlon[0]:.6f},{latlon[1]:.6f}"
    raise ValueError("Debes pasar place_id o latlon.")

@st.cache_data(ttl=600, show_spinner=False)
def get_place_details(place_id: str, language: str = "es") -> dict:
    try:
        fields = [
            "name", "rating", "user_ratings_total", "url", "googleMapsUri",
            "reviews", "photos", "editorial_summary"
        ]
        try:
            resp = gmaps.place(
                place_id=place_id,
                fields=fields,
                language=language,
                reviews_sort="newest",
                reviews_no_translations=False
            )
        except TypeError:
            resp = gmaps.place(place_id=place_id, fields=fields, language=language)
        result = resp.get("result", {}) if resp else {}
        if "url" not in result and "googleMapsUri" in result:
            result["url"] = result.get("googleMapsUri")
        return result
    except Exception:
        return {}

def place_photo_url(photo_reference: str, maxwidth: int = 640) -> str:
    base = "https://maps.googleapis.com/maps/api/place/photo"
    return f"{base}?maxwidth={maxwidth}&photoreference={quote_plus(photo_reference)}&key={GOOGLE_MAPS_API_KEY}"
'''.strip()

files["ranking.py"] = r'''
import math
import time
import numpy as np
import pandas as pd
import streamlit as st
from config import gmaps, W_RATING, W_REVIEWS, W_PROX

def geocode_address(address: str, language: str = "es", region: str = "es"):
    res = gmaps.geocode(address, language=language, region=region)
    if not res:
        raise ValueError("No se pudo geocodificar la direcci√≥n.")
    loc = res[0]["geometry"]["location"]
    return (loc["lat"], loc["lng"]), res[0]["formatted_address"]

def reverse_geocode(latlon: tuple[float, float], language: str = "es"):
    try:
        res = gmaps.reverse_geocode(latlon, language=language)
        if res:
            return res[0]["formatted_address"]
    except Exception:
        pass
    return f"{latlon[0]:.6f},{latlon[1]:.6f}"

def haversine_m(lat1, lon1, lat2, lon2):
    R = 6371000.0
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlmb = math.radians(lon2 - lon1)
    a = math.sin(dphi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(dlmb / 2) ** 2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return R * c

def compute_scores(df: pd.DataFrame, center_latlon: tuple[float, float], radius_m: int,
                   w_rating: float = W_RATING, w_reviews: float = W_REVIEWS, w_prox: float = W_PROX) -> pd.DataFrame:
    if df.empty:
        return df
    df = df.copy()
    df["rating"] = pd.to_numeric(df.get("rating", np.nan), errors="coerce")
    df["user_ratings_total"] = pd.to_numeric(df.get("user_ratings_total", 0), errors="coerce").fillna(0)

    c_lat, c_lon = center_latlon
    def _dist(row):
        lat, lon = row.get("lat"), row.get("lon")
        if pd.notna(lat) and pd.notna(lon):
            return haversine_m(c_lat, c_lon, float(lat), float(lon))
        return np.nan
    df["distance_m"] = df.apply(_dist, axis=1)

    df["rating_score"] = (df["rating"].fillna(0) / 5.0).clip(0, 1)
    max_reviews = max(1.0, float(df["user_ratings_total"].max()))
    df["reviews_score"] = (np.log1p(df["user_ratings_total"]) / np.log1p(max_reviews)).clip(0, 1)
    prox = 1.0 - (df["distance_m"] / float(radius_m))
    df["proximity_score"] = prox.clip(lower=0, upper=1).fillna(0)
    s = (w_rating * df["rating_score"] + w_reviews * df["reviews_score"] + w_prox * df["proximity_score"])
    denom = max(1e-9, (w_rating + w_reviews + w_prox))
    df["score"] = (s / denom).clip(0, 1)
    return df

@st.cache_data(ttl=300)
def places_nearby_all(location, keyword, radius=1500, open_now=True, language="es"):
    all_results = []
    page = gmaps.places_nearby(
        location=location,
        keyword=keyword,
        radius=radius,
        open_now=open_now,
        language=language
    )
    all_results.extend(page.get("results", []))
    token = page.get("next_page_token")
    while token:
        time.sleep(2)
        page = gmaps.places_nearby(page_token=token, language=language)
        all_results.extend(page.get("results", []))
        token = page.get("next_page_token")
    return all_results

def filter_by_rating_df(df: pd.DataFrame, min_rating=0.0) -> pd.DataFrame:
    if "rating" not in df.columns:
        df["rating"] = None
    df["rating"] = pd.to_numeric(df["rating"], errors="coerce")
    return df[df["rating"] >= float(min_rating)]
'''.strip()

files["routing.py"] = r'''
import numpy as np
import pandas as pd
import streamlit as st
from datetime import datetime
from config import gmaps

def _latlon_str(latlon):
    return f"{latlon[0]},{latlon[1]}"

@st.cache_data(ttl=180, show_spinner=False)
def route_total_seconds(origin_text: str, waypoints: tuple, dest_latlon: tuple, mode: str):
    try:
        r = gmaps.directions(
            origin_text,
            _latlon_str(dest_latlon),
            mode=mode,
            waypoints=list(waypoints) if waypoints else None,
            optimize_waypoints=False,
            departure_time=datetime.now()
        )
        if not r:
            return None
        secs = sum(leg["duration"]["value"] for leg in r[0]["legs"])
        return float(secs)
    except Exception:
        return None

@st.cache_data(ttl=180, show_spinner=False)
def optimize_route_order(origin_text: str, stops_latlon: list[tuple[float, float]], mode: str):
    if not stops_latlon:
        return [], [], None, None
    if len(stops_latlon) == 1:
        dest = stops_latlon[0]
        secs = route_total_seconds(origin_text, tuple(), dest, mode)
        return [], [], dest, secs

    dest = stops_latlon[-1]
    waypoints = stops_latlon[:-1]
    try:
        r = gmaps.directions(
            origin_text,
            _latlon_str(dest),
            mode=mode,
            waypoints=[_latlon_str(wp) for wp in waypoints],
            optimize_waypoints=True,
            departure_time=datetime.now()
        )
        if not r:
            return list(range(len(waypoints))), waypoints, dest, None
        order = r[0].get("waypoint_order", list(range(len(waypoints))))
        ordered_wp = [waypoints[i] for i in order]
        secs = sum(leg["duration"]["value"] for leg in r[0]["legs"])
        return order, ordered_wp, dest, float(secs)
    except Exception:
        secs = route_total_seconds(origin_text, tuple(_latlon_str(w) for w in waypoints), dest, mode)
        return list(range(len(waypoints))), waypoints, dest, secs

def label_from_ratio(ratio: float | None) -> str:
    if ratio is None or np.isnan(ratio):
        return ""
    if ratio <= 0.10:   return "genial"
    if ratio <= 0.25:   return "muy bien"
    if ratio <= 0.50:   return "normal"
    if ratio <= 1.00:   return "mal"
    return "muy mal"

def compute_multi_stop_detours(origin_text: str, selected_coords: list[tuple[float,float]], candidates_df, mode: str):
    if candidates_df.empty or len(selected_coords) == 0:
        candidates_df["detour_ratio"] = np.nan
        candidates_df["ruta"] = ""
        return candidates_df

    dest = selected_coords[-1]
    base_waypoints = tuple(_latlon_str(p) for p in selected_coords[:-1])
    base_secs = route_total_seconds(origin_text, base_waypoints, dest, mode)
    if not base_secs or base_secs <= 0:
        candidates_df["detour_ratio"] = np.nan
        candidates_df["ruta"] = ""
        return candidates_df

    many_paradas = len(selected_coords) > 6
    max_insert_positions = 1 if many_paradas else (len(selected_coords))

    ratios = []
    for _, row in candidates_df.iterrows():
        lat, lon = row.get("lat"), row.get("lon")
        if pd.isna(lat) or pd.isna(lon):
            ratios.append(np.nan)
            continue
        cand = (float(lat), float(lon))
        best_secs = None

        if max_insert_positions == 1:
            new_wp = list(base_waypoints) + [_latlon_str(cand)]
            secs = route_total_seconds(origin_text, tuple(new_wp), dest, mode)
            best_secs = secs
        else:
            for i in range(max_insert_positions + 1):
                new_wp = list(base_waypoints)
                new_wp.insert(i, _latlon_str(cand))
                secs = route_total_seconds(origin_text, tuple(new_wp), dest, mode)
                if secs:
                    best_secs = secs if (best_secs is None or secs < best_secs) else best_secs

        if best_secs and best_secs > 0:
            ratios.append(max(0.0, (best_secs - base_secs) / base_secs))
        else:
            ratios.append(np.nan)

    candidates_df = candidates_df.copy()
    candidates_df["detour_ratio"] = ratios
    candidates_df["ruta"] = candidates_df["detour_ratio"].apply(label_from_ratio)
    return candidates_df
'''.strip()

# app.py: keep all UI logic, calling into modules
files["app.py"] = r'''
# pruebas.py ‚Äî Recomendador Emocional con direcci√≥n (calle y n√∫mero), Nearby y rutas Google Maps
# Modo: SOLO ubicaci√≥n manual
# Requisitos: streamlit, googlemaps, requests, python-dotenv, pandas, numpy

import os
import time
import json
import math
import re
import unicodedata
import random
import requests
import numpy as np
import pandas as pd
import googlemaps
import streamlit as st
from dotenv import load_dotenv
from urllib.parse import quote_plus
from datetime import datetime

# --------- Config de p√°gina (primera llamada a st.*) ---------
st.set_page_config(page_title="Recomendador Emocional", layout="wide")

# ==== imports desde m√≥dulos refactorizados ====
from config import (
    gmaps, GEMINI_API_KEY, GOOGLE_MAPS_API_KEY,
    LIST_CONTAINER_HEIGHT_PX, W_RATING, W_REVIEWS, W_PROX
)
from taxonomy import _map_term_to_canon
from brain import (
    detect_mood_category, TONE_HINTS, _fallback_empathy,
    PROMPT_BRAIN_JSON, gemini_brain, normalize_to_nearby_keywords, mock_from_mood
)
from maps_io import (
    _maps_link, gm_embed_directions_url, maps_directions_link,
    gm_embed_place_url, get_place_details, place_photo_url
)
from ranking import (
    geocode_address, reverse_geocode, haversine_m, compute_scores,
    places_nearby_all, filter_by_rating_df
)
from routing import (
    route_total_seconds, optimize_route_order, label_from_ratio, compute_multi_stop_detours
)

# =====================================================================
# ======================  ESTADO INICIAL  =============================
# =====================================================================

if "suggested_terms" not in st.session_state:
    st.session_state.suggested_terms = []
if "raw_results_df" not in st.session_state:
    st.session_state.raw_results_df = pd.DataFrame()
if "results_df" not in st.session_state:
    st.session_state.results_df = pd.DataFrame()
if "selected_df" not in st.session_state:
    st.session_state.selected_df = pd.DataFrame()
if "center_latlon" not in st.session_state:
    st.session_state.center_latlon = (40.4168, -3.7038)  # Madrid por defecto
if "center_address" not in st.session_state:
    st.session_state.center_address = reverse_geocode(st.session_state.center_latlon)
if "editor_nonce" not in st.session_state:
    st.session_state.editor_nonce = 0
if "pending_resort" not in st.session_state:
    st.session_state.pending_resort = False
if "last_search_sig" not in st.session_state:
    st.session_state.last_search_sig = None
if "route_mode" not in st.session_state:
    st.session_state.route_mode = "driving"
if "intelligent_mode" not in st.session_state:
    st.session_state.intelligent_mode = False
if "optimize_waypoints" not in st.session_state:
    st.session_state.optimize_waypoints = True
if "prev_intelligent_mode" not in st.session_state:
    st.session_state.prev_intelligent_mode = st.session_state.intelligent_mode
if "empathy_message" not in st.session_state:
    st.session_state.empathy_message = ""
if "recent_terms" not in st.session_state:
    st.session_state.recent_terms = []  # para evitar repetir siempre lo mismo

# =====================================================================
# ======================  INTERFAZ  ===================================
# =====================================================================

st.title("üß†‚û°Ô∏èüìç Recomendador Emocional")

# Sidebar ubicaci√≥n y filtros (SOLO MANUAL)
st.sidebar.header("üìç Ubicaci√≥n y filtros")

addr_default = st.session_state.get("center_address", "")
addr_input = st.sidebar.text_input("Direcci√≥n (calle y n√∫mero, o lugar):", value=addr_default)
if st.sidebar.button("üìç Usar esta direcci√≥n"):
    try:
        (lat, lon), fmt = geocode_address(addr_input)
        st.session_state.center_latlon = (lat, lon)
        st.session_state.center_address = fmt
        st.sidebar.success(f"Direcci√≥n establecida: {fmt}")
    except Exception as e:
        st.sidebar.error(f"No se pudo geocodificar: {e}")

radius = st.sidebar.slider("Radio de b√∫squeda (m)", min_value=200, max_value=5000, value=1500, step=100)
open_now = st.sidebar.checkbox("Solo abiertos ahora", value=True)
min_rating = st.sidebar.slider("Puntuaci√≥n m√≠nima", min_value=0.0, max_value=5.0, value=0.0, step=0.1)

st.sidebar.caption(f"Direcci√≥n actual: {st.session_state.center_address}")
st.sidebar.map(pd.DataFrame([{"lat": st.session_state.center_latlon[0], "lon": st.session_state.center_latlon[1]}]))

# Paso 1: emociones ‚Üí lugares
st.subheader("1) Dime c√≥mo te sientes")
mood_text = st.text_area("Tu estado de √°nimo:", placeholder="Ej.: Estoy estresado, me vendr√≠a bien desconectar...")

def _remove_term(idx: int):
    try:
        del st.session_state.suggested_terms[idx]
        st.rerun()
    except Exception:
        pass

if st.button("üéØ Recomendar lugares"):
    if mood_text.strip():
        try:
            empathy, places_raw, cat = gemini_brain(mood_text, avoid_terms=st.session_state.recent_terms)
            # Normaliza a keywords Nearby
            places = normalize_to_nearby_keywords(places_raw, cat or "neutro", avoid=st.session_state.recent_terms)
            st.session_state.empathy_message = empathy
            st.session_state.suggested_terms = places
            # Actualiza recientes
            st.session_state.recent_terms = list(dict.fromkeys((st.session_state.recent_terms + places)))[-24:]
        except Exception as e:
            st.session_state.empathy_message = _fallback_empathy(mood_text)
            st.session_state.suggested_terms = mock_from_mood(mood_text, avoid=st.session_state.recent_terms)

# Mostrar mensaje emp√°tico si existe
if st.session_state.empathy_message:
    st.info(st.session_state.empathy_message)

# ---- Lista en casillas (grid) de 'Lugares sugeridos' con ‚úñ y a√±adir ----
st.subheader("Lugares sugeridos")

def render_term_cards(terms: list[str], cards_per_row: int = 4):
    if not terms:
        st.info("No hay sugerencias a√∫n. Usa ¬´Recomendar lugares¬ª o a√±ade alguna manualmente.")
        return
    st.caption("Pulsa ‚úñ para quitar un t√©rmino.")
    row_cols = None
    for i, term in enumerate(list(terms)):
        if i % cards_per_row == 0:
            row_cols = st.columns(cards_per_row, gap="small")
        col = row_cols[i % cards_per_row]
        with col:
            with st.container():
                inner = st.columns([0.8, 0.2])
                with inner[0]:
                    st.markdown(f"**{term}**")
                with inner[1]:
                    st.button("‚úñ", key=f"del_term_{i}", help=f"Descartar ¬´{term}¬ª", on_click=_remove_term, args=(i,))
                st.markdown("<hr style='margin:6px 0; opacity:0.2;'>", unsafe_allow_html=True)

render_term_cards(st.session_state.suggested_terms, cards_per_row=4)

with st.form("add_term_form", clear_on_submit=True):
    new_term = st.text_input("A√±adir tipo de lugar (se normaliza para Google Maps)", placeholder="p. ej., mirador, cafeter√≠a tranquila, jard√≠n bot√°nico‚Ä¶")
    add_clicked = st.form_submit_button("‚ûï A√±adir")
    if add_clicked:
        nt = (new_term or "").strip()
        if nt:
            # Normaliza manual tambi√©n a keyword Nearby
            cat_hint = detect_mood_category(mood_text or "")
            canon = _map_term_to_canon(nt, cat_hint)
            if canon not in st.session_state.suggested_terms:
                st.session_state.suggested_terms.append(canon)
                st.success(f"A√±adido: {canon}")
                st.rerun()
            else:
                st.warning("Ese t√©rmino ya est√° en la lista.")

place_terms = st.session_state.suggested_terms

# =====================================================================
# ======================  B√öSQUEDA NEARBY  ============================
# =====================================================================

def compute_nearby_df(terms: list[str], center_latlon, radius, open_now, language="es") -> pd.DataFrame:
    from maps_io import _maps_link  # asegurar import local
    by_id = {}
    any_results = False
    for term in terms:
        results = places_nearby_all(center_latlon, term, radius=radius, open_now=open_now, language=language)
        if not results and open_now:
            # Fallback por t√©rmino: si "abierto ahora" no devuelve nada, prueba sin filtro
            results = places_nearby_all(center_latlon, term, radius=radius, open_now=False, language=language)
        if results:
            any_results = True
        for p in results:
            locp = p.get("geometry", {}).get("location", {})
            pid = p.get("place_id")
            if not pid:
                continue
            photos = p.get("photos", []) or []
            photo_ref = photos[0].get("photo_reference") if (photos and isinstance(photos[0], dict)) else None

            if pid in by_id:
                by_id[pid]["_sug_set"].add(term)
                if p.get("rating", 0) and (p.get("rating", 0) > by_id[pid].get("rating", 0)):
                    by_id[pid]["rating"] = p.get("rating")
                if p.get("user_ratings_total", 0) and (p.get("user_ratings_total", 0) > by_id[pid].get("user_ratings_total", 0)):
                    by_id[pid]["user_ratings_total"] = p.get("user_ratings_total")
                if (not by_id[pid].get("photo_ref")) and photo_ref:
                    by_id[pid]["photo_ref"] = photo_ref
                continue

            by_id[pid] = {
                "‚úÖ": False,
                "_sug_set": set([term]),
                "sugerencia": term,
                "name": p.get("name"),
                "rating": p.get("rating"),
                "user_ratings_total": p.get("user_ratings_total"),
                "address": p.get("vicinity"),
                "lat": locp.get("lat"),
                "lon": locp.get("lng"),
                "place_id": pid,
                "maps_link": _maps_link(locp.get("lat"), locp.get("lng")),
                "photo_ref": photo_ref,
            }
    rows = []
    for rec in by_id.values():
        rec["sugerencia"] = ", ".join(sorted(rec["_sug_set"]))
        rec.pop("_sug_set", None)
        rows.append(rec)

    df = pd.DataFrame(rows)
    df = compute_scores(df, center_latlon, radius, w_rating=W_RATING, w_reviews=W_REVIEWS, w_prox=W_PROX)
    df = df.sort_values(by=["score"], ascending=[False]).reset_index(drop=True)
    return df

# Firma de b√∫squeda
search_sig = (tuple(sorted(place_terms)), st.session_state.center_latlon, int(radius), bool(open_now))

if place_terms:
    if st.session_state.last_search_sig != search_sig:
        new_df = compute_nearby_df(place_terms, st.session_state.center_latlon, radius, open_now, language="es")

        if not st.session_state.raw_results_df.empty and "place_id" in st.session_state.raw_results_df.columns:
            prev = st.session_state.raw_results_df[["place_id", "‚úÖ"]].drop_duplicates("place_id")
            new_df = new_df.merge(prev, on="place_id", how="left", suffixes=("", "_old"))
            if "‚úÖ_old" in new_df.columns:
                # Trata cualquier valor exactamente True como seleccionado; NaN y otros -> False
                new_df.loc[:, "‚úÖ"] = new_df["‚úÖ"].eq(True) | new_df["‚úÖ_old"].eq(True)
                new_df.drop(columns=["‚úÖ_old"], inplace=True)

        if "‚úÖ" in new_df.columns:
            new_df["‚úÖ"] = new_df["‚úÖ"].astype(bool)
            sort_cols = ["‚úÖ", "score"] if new_df["‚úÖ"].any() else ["score"]
            new_df = new_df.sort_values(by=sort_cols, ascending=[False] * len(sort_cols)).reset_index(drop=True)

        st.session_state.raw_results_df = new_df
        st.session_state.last_search_sig = search_sig
        st.session_state.pending_resort = True
else:
    if not st.session_state.raw_results_df.empty:
        st.session_state.raw_results_df = pd.DataFrame()
        st.session_state.results_df = pd.DataFrame()
        st.session_state.selected_df = pd.DataFrame()

# =====================================================================
# ======================  RESULTADOS CERCA  ============================
# =====================================================================

st.subheader("2) üîé Resultados cerca")

new_intelligent_mode = st.checkbox(
    "üß† Modo inteligente (c√°lculo de desv√≠os y etiquetas de ruta)",
    value=st.session_state.get("intelligent_mode", False),
    help="Al activarlo, estimamos c√≥mo encaja cada sitio en tu ruta (genial/muy bien/...). Esto puede tardar m√°s y consume cuota de la API."
)
if "prev_intelligent_mode" not in st.session_state:
    st.session_state.prev_intelligent_mode = new_intelligent_mode

if new_intelligent_mode != st.session_state.prev_intelligent_mode:
    st.session_state.intelligent_mode = new_intelligent_mode
    st.session_state.prev_intelligent_mode = new_intelligent_mode
    st.session_state.editor_nonce += 1
    st.session_state.pending_resort = True
    st.rerun()

st.session_state.intelligent_mode = new_intelligent_mode
if st.session_state.intelligent_mode:
    st.caption("Calculamos el impacto en tu ruta para priorizar lugares que te pillen de camino.")

def _sync_results_back_to_raw():
    if "results_df" in st.session_state and isinstance(st.session_state.results_df, pd.DataFrame) and not st.session_state.results_df.empty:
        res = st.session_state.results_df[["place_id", "‚úÖ"]].dropna(subset=["place_id"]).drop_duplicates("place_id")
        raw = st.session_state.raw_results_df
        if not raw.empty:
            raw = raw.merge(res, on="place_id", how="left", suffixes=("", "_new"))
            if "‚úÖ_new" in raw.columns:
                raw.loc[:, "‚úÖ"] = raw["‚úÖ_new"].combine_first(raw["‚úÖ"]).eq(True)
                raw = raw.drop(columns=["‚úÖ_new"])
            st.session_state.raw_results_df = raw

if not st.session_state.raw_results_df.empty:
    base = st.session_state.raw_results_df.copy()
    base = compute_scores(base, st.session_state.center_latlon, radius, w_rating=W_RATING, w_reviews=W_REVIEWS, w_prox=W_PROX)

    # Ruta base para etiquetas, si procede
    selected_coords = []
    if not base.empty and "‚úÖ" in base.columns:
        sel_raw = base[base["‚úÖ"] == True]  # noqa
        for _, r in sel_raw.iterrows():
            if pd.notna(r.get("lat")) and pd.notna(r.get("lon")):
                selected_coords.append((float(r["lat"]), float(r["lon"])))

    if st.session_state.intelligent_mode and len(selected_coords) >= 1:
        base = compute_multi_stop_detours(
            origin_text=st.session_state.center_address,
            selected_coords=selected_coords,
            candidates_df=base,
            mode=st.session_state.route_mode
        )
        if "ruta" not in base.columns:
            base["ruta"] = ""
        base["ruta"] = base["ruta"].fillna("").astype(str)
    else:
        base["detour_ratio"] = np.nan
        base["ruta"] = ""

    view_df = filter_by_rating_df(base, min_rating=min_rating)
    if "‚úÖ" in view_df.columns:
        view_df.loc[:, "‚úÖ"] = view_df["‚úÖ"].astype(bool)
    sort_cols = ["‚úÖ", "score"] if (st.session_state.get("pending_resort", False) or (not view_df.empty and view_df["‚úÖ"].any())) else ["score"]
    view_df = view_df.sort_values(by=sort_cols, ascending=[False] * len(sort_cols)).reset_index(drop=True)
    st.session_state.pending_resort = False

    # ---------- Tabla ----------
    def _toggle_check(place_id: str):
        val = st.session_state.get(f"rowcheck_{place_id}", False)
        raw = st.session_state.raw_results_df
        mask = raw["place_id"] == place_id
        if mask.any():
            raw.loc[mask, "‚úÖ"] = bool(val)
            st.session_state.raw_results_df = raw
        st.session_state.selected_df = st.session_state.raw_results_df[st.session_state.raw_results_df["‚úÖ"] == True].copy()  # noqa

    header_cols = ["‚úÖ", "Nombre", "Coincidi√≥ con", "Ruta" if st.session_state.intelligent_mode else None,
                   "Score", "Distancia (m)", "Rating", "Rese√±as"]
    header_cols = [h for h in header_cols if h is not None]
    col_widths = [0.7, 3.2, 2.8] + ([1.2] if st.session_state.intelligent_mode else []) + [1.0, 1.4, 1.1, 1.2]
    col_widths = col_widths[:len(header_cols)]
    hdr = st.columns(col_widths, gap="small")
    for c, h in zip(hdr, header_cols):
        c.markdown(f"**{h}**")

    with st.container(height=LIST_CONTAINER_HEIGHT_PX, border=True, width="stretch"):
        for _, row in view_df.iterrows():
            place_id = str(row.get("place_id"))
            name = row.get("name") or "Lugar"
            sug = row.get("sugerencia", "")
            ruta_tag = row.get("ruta", "") if st.session_state.intelligent_mode else None
            score = row.get("score")
            distm = row.get("distance_m")
            rating = row.get("rating")
            reviews_n = row.get("user_ratings_total")
            fallback_photo_ref = row.get("photo_ref")
            checked = bool(row.get("‚úÖ", False))

            cols = st.columns(col_widths, gap="small")

            with cols[0]:
                st.checkbox(
                    "Seleccionar",
                    label_visibility="collapsed",
                    key=f"rowcheck_{place_id}",
                    value=checked,
                    help="Seleccionar",
                    on_change=_toggle_check,
                    args=(place_id,)
                )

            with cols[1]:
                with st.popover(name, width="stretch"):
                    details = get_place_details(place_id)
                    # Foto
                    photo_shown = False
                    try:
                        photos = details.get("photos", []) or []
                        pref = None
                        if photos and isinstance(photos[0], dict):
                            pref = photos[0].get("photo_reference")
                        if not pref:
                            pref = fallback_photo_ref
                        if pref:
                            st.image(place_photo_url(pref, maxwidth=640), width="stretch")
                            photo_shown = True
                    except Exception:
                        pass
                    if not photo_shown:
                        st.caption("Sin foto principal disponible.")

                    # Cabecera rating / rese√±as
                    r = details.get("rating", rating)
                    ur = details.get("user_ratings_total", reviews_n)
                    head_bits = []
                    if r is not None and str(r) != "nan":
                        head_bits.append(f"‚≠ê {r}")
                    if ur is not None and str(ur) != "nan":
                        head_bits.append(f"¬∑ {int(ur)} rese√±as")
                    if head_bits:
                        st.markdown("**" + " ".join(head_bits) + "**")

                    # Rese√±as
                    reviews = details.get("reviews") or []
                    parsed = []
                    for rev in reviews[:3]:
                        author = rev.get("author_name") or rev.get("authorAttribution", {}).get("displayName") or "Usuario"
                        rr = rev.get("rating", "")
                        when = rev.get("relative_time_description") or rev.get("publishTime", "")
                        text = rev.get("text", "")
                        if isinstance(text, dict):
                            text = text.get("text", "")
                        text = (text or "").strip()
                        parsed.append((author, rr, when, text))
                    if parsed:
                        st.markdown("---")
                        st.markdown("**Rese√±as destacadas:**")
                        for (auth, rr, when, txt) in parsed:
                            st.markdown(f"**{auth}** ‚Äî ‚≠ê {rr} ¬∑ _{when}_  \n{txt if txt else '_(sin texto)_' }")
                    else:
                        st.caption("Sin rese√±as p√∫blicas.")

                    maps_url = details.get("url") or row.get("maps_link")
                    if maps_url:
                        st.markdown(f"[Ver en Google Maps ‚Üó]({maps_url})")

            with cols[2]:
                st.write(sug if sug else "")

            idx = 3
            if st.session_state.intelligent_mode:
                with cols[idx]:
                    st.write(ruta_tag if ruta_tag else "")
                idx += 1

            with cols[idx]:
                st.write(f"{(score or 0):.3f}")
            idx += 1

            with cols[idx]:
                st.write(f"{(distm or 0):.0f}")
            idx += 1

            with cols[idx]:
                st.write("" if (rating is None or str(rating) == "nan") else f"{float(rating):.1f}")
            idx += 1

            with cols[idx]:
                st.write("" if (reviews_n is None or str(reviews_n) == "nan") else int(reviews_n))

    st.session_state.results_df = view_df.copy()
    _sync_results_back_to_raw()
    st.session_state.selected_df = st.session_state.raw_results_df[st.session_state.raw_results_df["‚úÖ"] == True].copy()  # noqa
else:
    st.info("No hay resultados a√∫n. A√±ade o recomiende t√©rminos arriba para empezar.")

# =====================================================================
# ======================  SELECCIONADOS  ===============================
# =====================================================================

st.subheader("3) ‚úÖ Tus seleccionados")

def _on_remove_selected(place_id: str):
    if "raw_results_df" in st.session_state and isinstance(st.session_state.raw_results_df, pd.DataFrame) and not st.session_state.raw_results_df.empty:
        mask_raw = st.session_state.raw_results_df["place_id"] == place_id
        if mask_raw.any():
            st.session_state.raw_results_df.loc[mask_raw, "‚úÖ"] = False
    if "raw_results_df" in st.session_state and not st.session_state.raw_results_df.empty:
        st.session_state.selected_df = st.session_state.raw_results_df[st.session_state.raw_results_df["‚úÖ"] == True].copy()  # noqa
    else:
        st.session_state.selected_df = pd.DataFrame()
    st.session_state.editor_nonce += 1
    st.rerun()

def render_selected_cards(df: pd.DataFrame, cards_per_row: int = 2):
    if df.empty:
        st.info("Marca algunos lugares en la tabla del paso 2 para verlos aqu√≠.")
        return
    st.caption("Pulsa ‚úñ para quitar un lugar de tus seleccionados (tambi√©n se desmarcar√° en la tabla del paso 2).")
    records = df.to_dict("records")
    for i, row in enumerate(records):
        if i % cards_per_row == 0:
            row_cols = st.columns(cards_per_row, gap="small")
        col = row_cols[i % cards_per_row]
        with col:
            with st.container():
                name = row.get("name", "Lugar")
                addr = row.get("address", "")
                rating = row.get("rating", None)
                score = row.get("score", None)
                distm = row.get("distance_m", None)
                place_id = str(row.get("place_id", f"idx_{i}"))

                header_cols = st.columns([0.8, 0.2], gap="small")
                with header_cols[0]:
                    st.markdown(f"**{name}**")
                    sub = addr
                    if rating is not None and str(rating) != "nan":
                        sub += f" ¬∑ ‚≠ê {rating}"
                    if score is not None and str(score) != "nan":
                        sub += f" ¬∑ ‚ìà {score:.3f}"
                    if distm is not None and str(distm) != "nan":
                        sub += f" ¬∑ üìè {distm:.0f} m"
                    st.caption(sub)
                with header_cols[1]:
                    st.button(
                        "‚úñ",
                        key=f"rm_sel_{place_id}",
                        help="Quitar este lugar de tus seleccionados",
                        on_click=_on_remove_selected,
                        args=(place_id,)
                    )
                st.markdown("<hr style='margin:6px 0; opacity:0.2;'>", unsafe_allow_html=True)

render_selected_cards(st.session_state.selected_df, cards_per_row=2)

# =====================================================================
# ======================  RUTA FINAL  =================================
# =====================================================================

if not st.session_state.selected_df.empty:
    st.subheader("4) üó∫Ô∏è Ruta")
    st.caption(
        "Muestra la ruta usando Google Maps. Este bloque solo construye el enlace/iframe "
        "y Google se encarga de dibujar el mapa. "
        "Para priorizar lugares que 'pillen de camino' mientras eliges, usa el üß† Modo inteligente (arriba)."
    )

    st.session_state.route_mode = st.radio(
        "Modo de ruta:",
        ["driving", "walking", "bicycling", "transit"],
        horizontal=True,
        index=["driving","walking","bicycling","transit"].index(st.session_state.route_mode)
    )

    st.session_state.optimize_waypoints = st.checkbox(
        "Optimizar el orden de paradas para una ruta m√°s corta",
        value=st.session_state.optimize_waypoints,
        help="Usa la API de Directions para encontrar el orden √≥ptimo de las paradas (origen = tu direcci√≥n actual; destino = la √∫ltima selecci√≥n)."
    )

    selected_rows = st.session_state.selected_df.to_dict("records")
    selected_coords = [(float(r["lat"]), float(r["lon"])) for r in selected_rows if pd.notna(r.get("lat")) and pd.notna(r.get("lon"))]

    ordered_waypoints = []
    dest_latlon = None
    total_secs = None

    if st.session_state.optimize_waypoints:
        order_idx, ordered_waypoints, dest_latlon, total_secs = optimize_route_order(
            origin_text=st.session_state.center_address,
            stops_latlon=selected_coords,
            mode=st.session_state.route_mode
        )
        if dest_latlon is None and selected_coords:
            dest_latlon = selected_coords[-1]
    else:
        if len(selected_coords) >= 1:
            dest_latlon = selected_coords[-1]
            ordered_waypoints = selected_coords[:-1]
            total_secs = route_total_seconds(
                origin_text=st.session_state.center_address,
                waypoints=tuple(f"{w[0]},{w[1]}" for w in ordered_waypoints),
                dest_latlon=dest_latlon,
                mode=st.session_state.route_mode
            )

    if total_secs:
        mins = int(round(total_secs / 60.0))
        st.caption(f"Duraci√≥n estimada total: ~{mins} min (seg√∫n Google Directions).")

    dest_row = selected_rows[-1] if selected_rows else None

    if st.button("üó∫Ô∏è Ver ruta en el mapa (iframe)"):
        url = gm_embed_directions_url(
            origin_text=st.session_state.center_address,
            dest_place_id=dest_row.get("place_id") if dest_row else None,
            dest_text=dest_row.get("address") if dest_row else None,
            mode=st.session_state.route_mode,
            waypoints_latlon=ordered_waypoints if ordered_waypoints else None
        )
        st.components.v1.iframe(url, height=480, scrolling=False)

    maps_url = maps_directions_link(
        origin_text=st.session_state.center_address,
        dest_place_id=dest_row.get("place_id") if dest_row else None,
        dest_text=dest_row.get("address") if dest_row else None,
        mode=st.session_state.route_mode,
        waypoints_latlon=ordered_waypoints if ordered_waypoints else None,
        optimize_waypoints=st.session_state.optimize_waypoints
    )
    st.markdown(f"[Abrir en Google Maps ‚Üó]({maps_url})")
'''.strip()

# Write files
for name, content in files.items():
    with open(os.path.join(base, name), "w", encoding="utf-8") as f:
        f.write(content)

sorted(os.listdir(base))
